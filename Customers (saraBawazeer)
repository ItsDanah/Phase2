package Phase2;

public class Customers {

	// Static AVL holding all customers
	static AVL<Customers> customers = new AVL<>();

	// Each customer has its own AVL list of orders
	private AVL<Orders> ordersList;

	// Attributes
	private int customerId;
	private String name;
	private String email;

	// Constructor
	public Customers(int customerId, String name, String email) {
		this.customerId = customerId;
		this.name = name;
		this.email = email;
		this.ordersList = new AVL<>();
	}

	//----------------------------------------------------------------------------------//
	// Register a new customer 

	public static void registerCustomer(Customers customer) {// Time complexity: O(log n) - Space complexity: O(1)
		if (searchById(customer.getCustomerId()) != null) {
			System.out.println("Customer already exists in the system");
			return;
		}
		customers.insert(customer.getCustomerId(), customer);
		System.out.println("Customer registered successfully.");
	}

	//----------------------------------------------------------------------------------//
	// Place an order for the customer

	public void placeOrder(Orders order) {// Time complexity: O(log n) -  Space complexity: O(n)
		// Add the order to this customer's individual orders AVL
		ordersList.insert(order.getOrderId(), order);
	}

	//----------------------------------------------------------------------------------//
	// View the order history of the customer

	public void viewOrderHistory() {// Time complexity: O(n)- Space complexity: O(log n)
		if (ordersList.empty()) {
			System.out.println("No orders found.");
			return;
		}
		ordersList.traverseInOrder();
	}

	//----------------------------------------------------------------------------------//
	// Add a review for a product

	public void addReview(int productId, int ratingScore, String textComment) {//time complexity is O(log n) -  space complexity is O(1)

		if (ordersList.empty()) {
			System.out.println("No orders found");
			return;
		}
		// Generate a new review ID by finding max key in Reviews AVL
		int newKey = 1; // default if tree is empty
		if (!Reviews.getReviews().empty()) { // get static AVL from Reviews class
			AVLNode<Reviews> node = Reviews.getReviews().root;
			while (node.right != null) {
				node = node.right;
			}
			newKey = node.key + 1;
		}
		Reviews review = new Reviews(newKey, productId, customerId, ratingScore, textComment);// Create review with generated ID
		Reviews.addReview(review);// Add review to Reviews AVL
		System.out.println("Review added successfully.");
	}

	//----------------------------------------------------------------------------------//
	// Search for a customer by Id

	public static Customers searchById(int customerId) {//  Time complexity: O(log n) - Space complexity: O(1)
		if (customers.empty())
			return null;
		if (customers.findkey(customerId))
			return customers.retrieve();
		return null;
	}

	//----------------------------------------------------------------------------------//
	// List all Customers Sorted Alphabetically
	
	public static void printCustomersAlphabetically() {// time comp o(n log n) - space comp O(log n)
		if (customers.empty()) { // if AVL tree is empty
			System.out.println("No customers found.");
			return;
		}
		printNextAlphabetically(null); // start printing with no last printed (null because we havenâ€™t printed any names yet)
	}
	// repeatedly print one customer at a time in alphabetical order
	private static void printNextAlphabetically(String lastPrintedName) {
		AVLNode<Customers> next = findNextAlphabetical(customers.root, lastPrintedName, null); // to find the next customer alphabetically after lastPrintedName
		if (next == null)//if no more costomers 
			return; 
		System.out.println(next.data); // Print the current customer
		printNextAlphabetically(next.data.getName()); // print the next customer after this one
	}
	// helper method Find the customer with the smallest name that is greater than lastPrintedName (node is the current node in AVL tree we r checking)
	private static AVLNode<Customers> findNextAlphabetical(AVLNode<Customers> node, String lastPrintedName, AVLNode<Customers> smallest) {
		if (node == null)// reached end of subtree so return current smallest
			return smallest; 
		smallest = findNextAlphabetical(node.left, lastPrintedName, smallest); // check left subtree for smaller smallest
		if (lastPrintedName == null || node.data.getName().compareTo(lastPrintedName) > 0) { // if node name > last printed
			if (smallest == null || node.data.getName().compareTo(smallest.data.getName()) < 0) { // if smaller than current smallest
				smallest = node; // update smallest
			}
		}
		smallest = findNextAlphabetical(node.right, lastPrintedName, smallest); // check right subtree
		return smallest; // return best smallest found
	}

	//----------------------------------------------------------------------------------//

	public String toString() {
		return "Customer ID: " + customerId + " || Name: " + name + " || Email: " + email;
	}

	//----------------------------------------------------------------------------------//


	// Setter and getters
	public int getCustomerId() { 
		return customerId; }

	public String getName() { 
		return name; }

	public String getEmail() { 
		return email; }

	public void setName(String name) { 
		this.name = name; }

	public void setEmail(String email) { 
		this.email = email; }

	public AVL<Orders> getOrdersList() {
		return ordersList; }


}
