package Phase2;

public class Customers {

	// Static AVL tree holding all customers
	static AVL<Customers> customers = new AVL<>();

	// Each customer has his own AVL list of orders
	private AVL<Orders> ordersList;

	//~~~~~~~~~~~ Attributes ~~~~~~~~~~~
	private int customerId;
	private String name;
	private String email;

	//~~~~~~~~~~~ Constructor ~~~~~~~~~~~
	public Customers(int customerId, String name, String email) {
		this.customerId = customerId;
		this.name = name;
		this.email = email;
		this.ordersList = new AVL<>();
	}

	//~~~~~~~~~~~ Register a new customer ~~~~~~~~~~~

	public static void registerCustomer(Customers customer) {
		if (searchById(customer.getCustomerId()) != null) {
			System.out.println("Customer already exists in the system");
			return;
		}
		customers.insert(customer.getCustomerId(), customer);
		System.out.println("Customer registered successfully.");
	}

	//~~~~~~~~~~~ Place an order for the customer ~~~~~~~~~~~

	public void placeOrder(Orders order) {
		// Add the order to this customer's individual orders AVL tree
		ordersList.insert(order.getOrderId(), order);
	}

	//~~~~~~~~~~~ View the customer's order history ~~~~~~~~~~~

	public void viewOrderHistory() {
		if (ordersList.empty()) {
			System.out.println("No orders found.");
			return;
		}
		ordersList.traverseInOrder();
	}

	//~~~~~~~~~~~ Add review for a product ~~~~~~~~~~~

	public void addReview(int productId, int ratingScore, String textComment) {

		if (ordersList.empty()) {
			System.out.println("No orders found");
			return;
		}
		// Generate a new review ID by finding max key in the Reviews AVL tree
		int newKey = 1; // default review ID if tree is empty
		if (!Reviews.getReviews().empty()) { // get static AVL tree from Reviews class
			AVLNode<Reviews> node = Reviews.getReviews().root;
			while (node.right != null) {
				node = node.right;
			}
			newKey = node.key + 1; // The new Id for the review 
		}
		Reviews review = new Reviews(newKey, productId, customerId, ratingScore, textComment);
		Reviews.addReview(review);
		System.out.println("Review added successfully.");
	}

	//~~~~~~~~~~~ Search for a customer by ID ~~~~~~~~~~~

	public static Customers searchById(int customerId) {
		if (customers.empty())
			return null;
		if (customers.findkey(customerId)) // If customer was found
			return customers.retrieve();
		return null; // If customer wasn't found
	}

	//~~~~~~~~~~~ List all Customers Sorted Alphabetically ~~~~~~~~~~~

	public static void printCustomersAlphabetically() {
		if (customers.empty()) { // if AVL tree is empty
			System.out.println("No customers found.");
			return;
		}
		printNextAlphabetically(null); // Start printing with no last printed parameter (null because we havenâ€™t printed any names yet)
	}

	// Repeatedly print one customer at a time in alphabetical order
	private static void printNextAlphabetically(String lastPrintedName) {
		AVLNode<Customers> next = findNextAlphabetical(customers.root, lastPrintedName, null); // to find the next customer alphabetically after lastPrintedName
		if (next == null)// means no more customers left to print 
			return; 
		System.out.println(next.data); // Print the current customer
		printNextAlphabetically(next.data.getName()); // Print the next customer
	}

	// Method to find the customer with the smallest name that is greater than lastPrintedName (node is the current node in AVL tree that we are checking)
	private static AVLNode<Customers> findNextAlphabetical(AVLNode<Customers> node, String lastPrintedName, AVLNode<Customers> smallest) {
		if (node == null) // reached end of subtree so return current smallest
			return smallest; 
		smallest = findNextAlphabetical(node.left, lastPrintedName, smallest); // check left subtree for a possible smaller smallest value
		if (lastPrintedName == null || node.data.getName().compareToIgnoreCase(lastPrintedName) > 0) { // if node name > last printed
			if (smallest == null || node.data.getName().compareToIgnoreCase(smallest.data.getName()) < 0) { // if node is smaller than current smallest
				smallest = node; // update smallest
			}
		}
		smallest = findNextAlphabetical(node.right, lastPrintedName, smallest); // check right subtree
		return smallest; // return best smallest found
	}

	//~~~~~~~~~~~ ToString ~~~~~~~~~~~

	public String toString() {
		return "Customer ID: " + customerId + " || Name: " + name + " || Email: " + email;
	}

	//~~~~~~~~~~~ Setters and getters ~~~~~~~~~~~

	public int getCustomerId() { 
		return customerId; }

	public String getName() { 
		return name; }

	public String getEmail() { 
		return email; }

	public void setName(String name) { 
		this.name = name; }

	public void setEmail(String email) { 
		this.email = email; }

	public AVL<Orders> getOrdersList() {
		return ordersList; }


}
