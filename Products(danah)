package Phase2;

public class Products {

	// Static AVL tree holding all products made in the system
	private static AVL<Products> products = new AVL<>();

	// Each product has its own AVL tree of reviews
	private AVL<Reviews> reviews; 
	private int productId; // key of the product
	private String name; // name of the product
	private double price; // price of the product
	private int stock; // the number of this product available

	//----------------------------------------------------------------------------------//
	// Constructor:

	public Products(int productId, String name, double price, int stock) {
		this.productId = productId;
		this.name = name;
		this.price = price;
		this.stock = stock;
		this.reviews = new AVL<>();
	}

	//----------------------------------------------------------------------------------//
	// Add a new product

	public static void addProducts(Products product) {// Time complexity: O(log n) - Space complexity: O(1)

		if (products.findkey(product.getProductId()) == true) {// Check if product already exists
			System.out.println("Product already exists");
			return;
		}
		products.insert(product.getProductId(),product);
		System.out.println("Product added successfully.");
	}

	//----------------------------------------------------------------------------------//
	// Remove a product by Id

	public void removeProduct(int productId) {// Time complexity: O(log n) - Space complexity: O(1)
		if (products.empty()) {
			System.out.println("No products found");
			return;
		}

		if (products.findkey(productId)) {
			products.removeKey(productId);
			System.out.println("Product removed successfully");
			return;
		}
		System.out.println("Product not found");
	}

	//----------------------------------------------------------------------------------//
	// Update the price and stock for a product

	public void updateProducts(int productId, double price, int stock) {// Time complexity: O(log n) - Space complexity: O(1)
		if (!products.findkey(productId)) {
			System.out.println("No product found with that ID");
			return;
		}
		Products p = products.retrieve();
		p.setPrice(price);
		p.setStock(stock);
		System.out.println("Product updated successfully");
	}

	//----------------------------------------------------------------------------------//
	// Search for a product by its key

	public static Products searchById(int productID) {// Time complexity: O(log n) - Space complexity: O(1)

		if (!products.findkey(productID))
			return null;
		return products.retrieve();

	}

	//----------------------------------------------------------------------------------//
	// Track out of stock products ( stock=0 )

	public static AVL<Products> trackOutOfStock() {// Time complexity: O(n log n) - Space complexity: O(n)
		AVL<Products> outOfStock = new AVL<>();
		traverseOutOfStock(products.root, outOfStock);
		return outOfStock;
	}

	private static void traverseOutOfStock(AVLNode<Products> node, AVL<Products> outOfStock) {
		if (node == null)
			return;
		traverseOutOfStock(node.left, outOfStock);
		if (node.data.stock == 0)
			outOfStock.insert(node.data.productId, node.data);

		traverseOutOfStock(node.right, outOfStock);
	}


	// ----------------------------------
	// add review
	public void addReview(Reviews review) {// Time complexity: O(log n) - Space complexity: O(1)
		reviews.insert(review.getReviewId(), review);
	}

	//-------------------------------------------------------------- 
	// get average rating

	public int averageRating() {// Time complexity: O(n) - Space complexity: O(log n)
		if (reviews.empty())
			return 0;
		// to hold [sum, count]
		int[] result = averageRatingRec(reviews.root);
		if (result[1] == 0) return 0;
		return result[0] / result[1];
	}

	private int[] averageRatingRec(AVLNode<Reviews> node) {
		if (node == null)
			return new int[]{0, 0};

		int[] left = averageRatingRec(node.left);
		int[] right = averageRatingRec(node.right);

		int totalSum = left[0] + right[0] + node.data.getRatingScore();
		int totalCount = left[1] + right[1] + 1;

		return new int[]{totalSum, totalCount};
	}

	//-------------------------------------------------------------- 
	// Top 3 products by average rating

		public static void printTop3() {// Time complexity: O(n) - Space complexity: O(log n)
			if (products.empty()) {
				System.out.println("No products found.");
				return;
			}

			// Array to hold the top 3 products. Index 0: 1st, 1: 2nd, 2: 3rd.
			Products[] topProducts = new Products[3];
			traverseTop(products.root, topProducts);

			System.out.println("Top 3 products by average rating:");
			print(topProducts);
		}

		private static void traverseTop(AVLNode<Products> node, Products[] topProducts) {
			if (node == null) return;

			traverseTop(node.left, topProducts);
			Insert(node.data, topProducts);
			traverseTop(node.right, topProducts);
		}

		// Helper method to insert product into the top 3 array if its rating is high enough
		private static void Insert(Products p, Products[] topProducts) {
			int avg = p.averageRating();

			if (topProducts[0] == null || avg > topProducts[0].averageRating()) {
				// Shift 2nd to 3rd, 1st to 2nd, insert new as 1st
				topProducts[2] = topProducts[1];
				topProducts[1] = topProducts[0];
				topProducts[0] = p;
			}
			else if (topProducts[1] == null || avg > topProducts[1].averageRating()) {
				// Shift 2nd to 3rd, insert new as 2nd
				topProducts[2] = topProducts[1];
				topProducts[1] = p;
			}
			else if (topProducts[2] == null || avg > topProducts[2].averageRating()) {
				// Insert new as 3rd
				topProducts[2] = p;
			}
		}


		// Print the contents of the topProducts
		private static void print(Products[] topProducts) {
			if (topProducts[0] != null) System.out.println(topProducts[0] + " || Avg Rating: " + topProducts[0].averageRating());
			if (topProducts[1] != null) System.out.println(topProducts[1] + " || Avg Rating: " + topProducts[1].averageRating());
			if (topProducts[2] != null) System.out.println(topProducts[2] + " || Avg Rating: " + topProducts[2].averageRating());
		}

	//-----------------------------------------------------------------
	// Range Query by price

	public static AVL<Products> rangeQueryByPrice(double minPrice, double maxPrice) { // Time complexity: O(log n) - Space complexity: O(log n)
		AVL<Products> result = new AVL<>();
		rangeRec(products.root, minPrice, maxPrice, result);
		return result;
	}

	private static void rangeRec(AVLNode<Products> node, double min, double max, AVL<Products> out) {
		if (node == null) return;

		rangeRec(node.left, min, max, out);

		if (node.data.price >= min && node.data.price <= max)
			out.insert(node.data.productId, node.data);

		rangeRec(node.right, min, max, out);
	}


	//----------------------------------------------------------------------------------//

	public String toString() {
		return "Product ID: " + productId + " || Name: " + name + " || Price: " + price + " || Stock: " + stock;
	}

	//----------------------------------------------------------------------------------//
	// Setters and getters

	public int getProductId() { 
		return productId; }

	public String getName() { 
		return name; }

	public double getPrice() { 
		return price; }

	public int getStock() { 
		return stock; }

	public void setPrice(double price) { 
		this.price = price; }

	public void setStock(int stock) { 
		this.stock = stock; }

	public AVL<Reviews> getReviewsList() { 
		return reviews; }

	public static AVL<Products> getProducts() { 
		return products; 
	}
}
