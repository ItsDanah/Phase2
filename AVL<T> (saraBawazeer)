package Phase2;

public class AVL <T> {

	AVLNode<T> root, current;

	/** Creates a new instance of AVL */
	public AVL() {
		root = current = null;
	}
	public boolean empty() {
		return root == null;
	}
	public boolean full() {
		return false;
	}
	public T retrieve () {
		return current.data;
	}

	public boolean findkey(int tkey) {
		AVLNode<T> p = root,q = root;

		if(empty())
			return false;
		while(p != null) {
			q = p;
			if(p.key == tkey) {
				current = p;
				return true;
			}
			else if(tkey < p.key)
				p = p.left;
			else
				p = p.right;
		}
		current = q;
		return false;
	}
	
	

	public boolean insert(int k, T val) {
		AVLNode<T> p, q = current;

		if(findkey(k)) {
			current = q;  // findkey() modified current
			return false; // key already in the BST
		}

		p = new AVLNode<T>(k, val);
		if (empty()) {
			root = current = p;
			return true;
		}
		else {
			// current is pointing to parent of the new key
			if (k < current.key)
				current.left = p;
			else
				current.right = p;
			current = p;
			return true;
		}
	}
	
	

	private void deleteNode(AVLNode<T> n,AVLNode<T> parent){
		// parent is the parent of n. The method deletes node n (case 1 and 2)
		AVLNode<T> child;
		if(n.left!=null)
			child=n.left;
		else
			child=n.right;
		if (parent == null) { // No parent for p, root must change
			root = child;  
		} else {
			if (n.key- parent.key < 0) {
				parent.left = child;
			} else {
				parent.right=child;
			}
		}
	}







	public boolean removeKey(int k) {
		// Search for k
		AVLNode<T> p = root;
		AVLNode<T> q = null; // Parent of p
		boolean found=false;
		while ((p != null)&&(!found)) {
			int res = k - p.key;
			if (res < 0) {
				q = p;
				p = p.left;
			} else if (res > 0) {
				q = p;
				p = p.right;
			} else // Found the key
				found=true;
		}
		if(found){           
			// Check the three cases
			if ((p.left != null) && (p.right != null)) { // Case 3: two children
				// Search for the min in the right subtree
				AVLNode<T> min = p.right;
				q = p;
				while (min.left != null) {
					q = min;
					min = min.left;
				}
				p.key = min.key;
				p.data = min.data;
				deleteNode(min,q);
			}
			else //case 1 and 2
				deleteNode(p,q);
			current = root;
			return true;
		}
		return false;
	}


}
