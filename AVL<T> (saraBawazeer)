package Phase2;

public class AVL<T> {
	AVLNode<T> root, current; 

	//-------------------- Constructor
	public AVL() {
		root = current = null;
	}

	//-------------------- Check if tree is empty
	public boolean empty() {
		return root == null;
	}

	//-------------------- Tree never full
	public boolean full() {
		return false;
	}

	//-------------------- Retrieve data at current node 
	public T retrieve() {
		return current.data;
	}
	
	//-------------------- update data at node 
	public boolean update(int tkey, T val) {
		if (findkey(tkey)) { // uses existing findkey
			current.data = val; // update data
			return true; // success
		}
		return false;  // key not found
	}
	
	//-------------------- findKey (iterative)
	public boolean findkey(int tkey) {
		AVLNode<T> p = root,q = root;

		if(empty())
			return false;
		while(p != null) {
			q = p;
			if(p.key == tkey) {
				current = p;
				return true;
			}
			else if(tkey < p.key)
				p = p.left;
			else
				p = p.right;
		}
		current = q; // parent where key would be attached
		return false;
	}

	//-------------------- insert (with rebalance)
	public boolean insert(int k, T val) {
		AVLNode<T> p, q = current;

		if (findkey(k)) {
			current = q;
			return false;
		}

		p = new AVLNode<T>(k, val);
		if (empty()) {
			root = current = p;
			root = rebalanceRec(root); // rebalance AVL 
			return true;
		} 
		else {
			if (k < current.key)
				current.left = p;
			else 
				current.right = p;
			current = p;
			root = rebalanceRec(root); // rebalance AVL
			return true;
		}
	}

	//-------------------- remove (with rebalance)
	public boolean removeKey(int k) {
		AVLNode<T> p = root;
		AVLNode<T> q = null; // parent of p
		boolean found = false;
		while ((p != null) && (!found)) {
			int res = k - p.key;
			if (res < 0) {
				q = p;
				p = p.left;
			} else if (res > 0) {
				q = p;
				p = p.right;
			} else // Found the key
				found = true;
		}
		if (found) {
			if ((p.left != null) && (p.right != null)) { // Case 3: two children
				// Search for the min in the right subtree
				AVLNode<T> min = p.right;
				q = p;
				while (min.left != null) {
					q = min;
					min = min.left;
				}
				p.key = min.key;
				p.data = min.data;
				deleteNode(min, q);
			} else  // one or no child
				deleteNode(p, q);
			root = rebalanceRec(root); // rebalance AVL
			current = root;
			return true;
		}
		return false;
	}

	//-------------------- deleteNode 
	private void deleteNode(AVLNode<T> n, AVLNode<T> parent) {
		AVLNode<T> child;
		if (n.left != null) {
			child = n.left;
		} else {
			child = n.right;
		}
		if (parent == null) {
			root = child;
		} else {
			if (n.key - parent.key < 0) {
				parent.left = child;
			} else {
				parent.right = child;
			}
		}
	}

	//-------------------- Traverse (in-order)
	public void traverseInOrder() {
		traverseInOrderRec(root);
	}
	private void traverseInOrderRec(AVLNode<T> node) {
		if (node != null) {
			traverseInOrderRec(node.left);
			System.out.println("Key: " + node.key + ", Data: " + node.data);
			traverseInOrderRec(node.right);
		}
	}

	//-------------------- rebalanceRec (post-order with balancing)
	private AVLNode<T> rebalanceRec(AVLNode<T> node) {
		if (node == null) {
			return null;
		}
		node.left = rebalanceRec(node.left);
		node.right = rebalanceRec(node.right);
		return balance(node);
	}

	//-------------------- balance (AVL rotation logic)
	private AVLNode<T> balance(AVLNode<T> node) {
		updateBalance(node);
		if (node.bal.getValue() > 1) { // left-heavy
			if (height(node.left.left) >= height(node.left.right)) {
				node = rotateLL(node);
			} else {
				node = rotateLR(node);
			}
		} else if (node.bal.getValue() < -1) { // right-heavy
			if (height(node.right.right) >= height(node.right.left)) {
				node = rotateRR(node);
			} else {
				node = rotateRL(node);
			}
		}
		return node;
	}

	//-------------------- updateBalance (null=-1, leaf=0)
	private void updateBalance(AVLNode<T> node) {
		int leftHeight = height(node.left);
		int rightHeight = height(node.right);
		int diff = leftHeight - rightHeight;
		if (diff == 1) {
			node.bal = Balance.PlusOne;
		} else if (diff == 0) {
			node.bal = Balance.Zero;
		} else {
			node.bal = Balance.MinusOne;
		}
	}

	//-------------------- height (null=-1, leaf=0)
	private int height(AVLNode<T> node) {
		if (node == null) {
			return -1;
		}
		return 1 + Math.max(height(node.left), height(node.right));
	}

	//-------------------- Rotations
	private AVLNode<T> rotateLL(AVLNode<T> node) {
		AVLNode<T> newRoot = node.left;
		node.left = newRoot.right;
		newRoot.right = node;
		updateBalance(node);
		updateBalance(newRoot);
		return newRoot;
	}

	private AVLNode<T> rotateRR(AVLNode<T> node) {
		AVLNode<T> newRoot = node.right;
		node.right = newRoot.left;
		newRoot.left = node;
		updateBalance(node);
		updateBalance(newRoot);
		return newRoot;
	}

	private AVLNode<T> rotateLR(AVLNode<T> node) {
		node.left = rotateRR(node.left);
		return rotateLL(node);
	}

	private AVLNode<T> rotateRL(AVLNode<T> node) {
		node.right = rotateLL(node.right);
		return rotateRR(node);
	}


	//-------------------- deleteSubtree 
	public void deleteSubtree() {
		if (current == root) {
			root = null;
			current = null;
		} else {
			AVLNode<T> p = current;
			current = findParent(p); // find parent and set as current
			if (current.left == p) {
				current.left = null;
			} else {
				current.right = null;
			}
			current = root; // reset current to root
		}
	}

	// findParent (for deleteSubtree) Recursive
	private AVLNode<T> findParent(AVLNode<T> p) {
		return findParentRec(p, root);
	}
	 
	private AVLNode<T> findParentRec(AVLNode<T> p, AVLNode<T> t) {
		if (t == null) {
			return null;
		} else {
			if (t.left == p || t.right == p) {
				return t; // parent found
			} else {
				AVLNode<T> q = findParentRec(p, t.left);
				if (q != null) {
					return q;
				} else {
					return findParentRec(p, t.right);
				}
			}
		}
	}
}

