package Phase2;

public class AVL<T> {
	AVLNode<T> root, current; 

	//~~~~~~~~~~~ Constructor ~~~~~~~~~~~
	public AVL() {
		root = current = null;
	}

	//~~~~~~~~~~~ Is tree empty? ~~~~~~~~~~~
	public boolean empty() {
		return root == null;
	}

	//~~~~~~~~~~~ Tree is never full ~~~~~~~~~~~
	public boolean full() {
		return false;
	}

	//~~~~~~~~~~~ Retrieve data at the current node  ~~~~~~~~~~~
	public T retrieve() {
		return current.data;
	}

	//~~~~~~~~~~~ Update data of the node at the given key ~~~~~~~~~~~
	public boolean update(int tkey, T val) {
		if (findkey(tkey)) { // If the given key exists
			current.data = val;
			return true; // Success, data is updated
		}
		return false;  // Fail, key not found
	}

	//~~~~~~~~~~~ Height (null=-1, leaf=0) ~~~~~~~~~~~
	private int height(AVLNode<T> node) {
		if (node == null) {
			return -1;
		}
		return 1 + Math.max(height(node.left), height(node.right));
	}

	//~~~~~~~~~~~ Set the current at the given key ~~~~~~~~~~~
	public boolean findkey(int tkey) {
		AVLNode<T> p = root,q = root; // q is parent of p

		if(empty())
			return false;
		while(p != null) {
			q = p;
			if(p.key == tkey) {
				current = p;
				return true;
			}
			else if(tkey < p.key)
				p = p.left;
			else
				p = p.right;
		}
		current = q; // Parent where key should be attached when inserted
		return false;
	}

	//~~~~~~~~~~~ Insert and rebalance  ~~~~~~~~~~~
	public boolean insert(int k, T val) {
		AVLNode<T> p, q = current; 

		if (findkey(k)) { // findkey() modified current
			current = q; 
			return false; // Key already exists
		}

		p = new AVLNode<T>(k, val);
		if (empty()) {
			root = current = p;
			root = rebalanceRec(root); // Rebalance AVL 
			return true;
		} 
		else {  // current is pointing to parent of the new key
			if (k < current.key)
				current.left = p;
			else 
				current.right = p;
			current = p;
			root = rebalanceRec(root); // Rebalance AVL
			return true;
		}
	}

	//~~~~~~~~~~~ Remove and rebalance  ~~~~~~~~~~~
	public boolean removeKey(int k) {
		AVLNode<T> p = root;
		AVLNode<T> q = null; // q is parent of p
		boolean found = false;
		// Search for k
		while ((p != null) && (!found)) {
			int res = k - p.key;
			if (res < 0) {
				q = p;
				p = p.left;
			} else if (res > 0) {
				q = p;
				p = p.right;
			} else // Found the key
				found = true;
		}
		if (found) {
			if ((p.left != null) && (p.right != null)) { // Case 3: two children
				// Search for the min in the right subtree
				AVLNode<T> min = p.right;
				q = p;
				while (min.left != null) {
					q = min;
					min = min.left;
				}
				p.key = min.key; // p is the root of the right subtree
				p.data = min.data;
				deleteNode(min, q); // q is the parent of min in this case
			} else  // Case 1&2: one or no child
				deleteNode(p, q); 
			root = rebalanceRec(root); // rebalance AVL
			current = root;
			return true;
		}
		return false;
	}

	//~~~~~~~~~~~ Delete the node  ~~~~~~~~~~~
	private void deleteNode(AVLNode<T> n, AVLNode<T> parent) {
		AVLNode<T> child;
		if (n.left != null) {
			child = n.left;
		} else {
			child = n.right;
		}
		if (parent == null) { // If the deleted node is the root (the parent of the root is null)
			root = child;
		} else {
			if (n.key - parent.key < 0) {
				parent.left = child;
			} else {
				parent.right = child;
			}
		}
	}

	//~~~~~~~~~~~ Traverse (in order)  ~~~~~~~~~~~
	public void traverseInOrder() {
		traverseInOrderRec(root);
	}
	private void traverseInOrderRec(AVLNode<T> node) { // left child > parent > right child
		if (node != null) {
			traverseInOrderRec(node.left);
			System.out.println("Key: " + node.key + ", Data: " + node.data);
			traverseInOrderRec(node.right);
		}
	}

	//~~~~~~~~~~~ Rebalance  ~~~~~~~~~~~
	private AVLNode<T> rebalanceRec(AVLNode<T> node) {
		if (node == null) {
			return null;
		}
		node.left = rebalanceRec(node.left);
		node.right = rebalanceRec(node.right);
		return balance(node);
	}

	//~~~~~~~~~~~ Balance (AVL rotation logic) ~~~~~~~~~~~
	//   >1  right-heavy, < -1  lrft-heavy
	private AVLNode<T> balance(AVLNode<T> node) {
	    updateBalance(node);
	    if (node.bal.getValue() > 1) { 
	        // right-heavy 
	        if (height(node.right.right) >= height(node.right.left)) {
	            node = rotateRR(node);   
	        } else {
	            node = rotateRL(node);   
	        }

	    } else if (node.bal.getValue() < -1) {
	        //   left-heavy 
	        if (height(node.left.left) >= height(node.left.right)) {
	            node = rotateLL(node);  
	        } else {
	            node = rotateLR(node);  
	        }
	    }

	    return node;
	}


	//~~~~~~~~~~~ Update balance (null=-1, leaf=0)  ~~~~~~~~~~~
	// CHANGED: balance factor is now (rightHeight - leftHeight)
	private void updateBalance(AVLNode<T> node) {
	    int leftHeight = height(node.left);
	    int rightHeight = height(node.right);
	    int diff = rightHeight - leftHeight; 

	    if (diff == 1) {
	        node.bal = Balance.PlusOne;
	    } else if (diff == 0) {
	        node.bal = Balance.Zero;
	    } else {
	        node.bal = Balance.MinusOne;
	    }
	}



	//~~~~~~~~~~~ Rotations  ~~~~~~~~~~~
	private AVLNode<T> rotateLL(AVLNode<T> node) {
		AVLNode<T> newRoot = node.left;
		node.left = newRoot.right;
		newRoot.right = node;
		updateBalance(node);
		updateBalance(newRoot);
		return newRoot;
	}

	private AVLNode<T> rotateRR(AVLNode<T> node) {
		AVLNode<T> newRoot = node.right;
		node.right = newRoot.left;
		newRoot.left = node;
		updateBalance(node);
		updateBalance(newRoot);
		return newRoot;
	}

	private AVLNode<T> rotateLR(AVLNode<T> node) {
		node.left = rotateRR(node.left);
		return rotateLL(node);
	}

	private AVLNode<T> rotateRL(AVLNode<T> node) {
		node.right = rotateLL(node.right);
		return rotateRR(node);
	}

	//~~~~~~~~~~~ Delete subtree  ~~~~~~~~~~~
	public void deleteSubtree() {
		if (current == root) {
			root = null;
			current = null;
		} else {
			AVLNode<T> p = current;
			current = findParent(p); // Find parent and set as current
			if (current.left == p) {
				current.left = null;
			} else {
				current.right = null;
			}
			current = root; // Reset current to root
		}
	}

	//~~~~~~~~~~~ Find parent  ~~~~~~~~~~~
	private AVLNode<T> findParent(AVLNode<T> p) {
		return findParentRec(p, root);
	}

	private AVLNode<T> findParentRec(AVLNode<T> p, AVLNode<T> t) {
		if (t == null) {
			return null;
		} else {
			if (t.left == p || t.right == p) {
				return t; // Parent found
			} else {
				AVLNode<T> q = findParentRec(p, t.left);
				if (q != null) {
					return q;
				} else {
					return findParentRec(p, t.right);
				}
			}
		}
	}
}
