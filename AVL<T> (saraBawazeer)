package project212;

public class AVLTree<T> {
	AVLNode<T> root, current; // same as BST: root and current

	//-------------------- Constructor
	public AVLTree() {
		root = current = null;
	}

	//-------------------- Check if tree is empty
	public boolean empty() {
		return root == null;
	}

	//-------------------- Tree never full
	public boolean full() {
		return false;
	}

	//-------------------- Retrieve data at current node (same as BST)
	public T retrieve() {
		return current.data;
	}

	//-------------------- FINDKEY (iterative, same as BST)
	public boolean findkey(int tkey) {
		AVLNode<T> p = root;
		AVLNode<T> q = root;
		if (empty()) {
			return false;
		}
		while (p != null) {
			q = p;
			if (p.key == tkey) {
				current = p;
				return true;
			} else if (tkey < p.key) {
				p = p.left;
			} else {
				p = p.right;
			}
		}
		current = q; // parent where key would be attached
		return false;
	}

	//-------------------- INSERT (BST logic + AVL rebalance)
	public boolean insert(int k, T val) {
		AVLNode<T> p, q = current;
		if (findkey(k)) {
			current = q;
			return false;
		}
		p = new AVLNode<T>(k, val);
		if (empty()) {
			root = current = p;
			root = rebalanceRec(root); // rebalance AVL
			return true;
		} else {
			if (k < current.key) {
				current.left = p;
			} else {
				current.right = p;
			}
			current = p;
			root = rebalanceRec(root); // rebalance AVL
			return true;
		}
	}

	//-------------------- REMOVE (BST logic + AVL rebalance)
	public boolean removeKey(int k) {
		AVLNode<T> p = root;
		AVLNode<T> q = null; // parent
		boolean found = false;
		while ((p != null) && (!found)) {
			int res = k - p.key;
			if (res < 0) {
				q = p;
				p = p.left;
			} else if (res > 0) {
				q = p;
				p = p.right;
			} else {
				found = true;
			}
		}
		if (found) {
			if ((p.left != null) && (p.right != null)) { // two children
				AVLNode<T> min = p.right;
				q = p;
				while (min.left != null) {
					q = min;
					min = min.left;
				}
				p.key = min.key;
				p.data = min.data;
				deleteNode(min, q);
			} else { // one or no child
				deleteNode(p, q);
			}
			root = rebalanceRec(root); // rebalance AVL
			current = root;
			return true;
		}
		return false;
	}

	//-------------------- deleteNode helper (BST)
	private void deleteNode(AVLNode<T> n, AVLNode<T> parent) {
		AVLNode<T> child;
		if (n.left != null) {
			child = n.left;
		} else {
			child = n.right;
		}
		if (parent == null) {
			root = child;
		} else {
			if (n.key - parent.key < 0) {
				parent.left = child;
			} else {
				parent.right = child;
			}
		}
	}

	//-------------------- Traverse in-order (prints key/data)
	public void traverseInOrder() {
		traverseInOrderRec(root);
	}

	private void traverseInOrderRec(AVLNode<T> node) {
		if (node != null) {
			traverseInOrderRec(node.left);
			System.out.println("Key: " + node.key + ", Data: " + node.data);
			traverseInOrderRec(node.right);
		}
	}

	//-------------------- rebalanceRec (post-order AVL balancing)
	private AVLNode<T> rebalanceRec(AVLNode<T> node) {
		if (node == null) {
			return null;
		}
		node.left = rebalanceRec(node.left);
		node.right = rebalanceRec(node.right);
		return balance(node);
	}

	//-------------------- balance (AVL rotation logic)
	private AVLNode<T> balance(AVLNode<T> node) {
		updateBalance(node);
		if (node.bal.getValue() > 1) { // left-heavy
			if (height(node.left.left) >= height(node.left.right)) {
				node = rotateLL(node);
			} else {
				node = rotateLR(node);
			}
		} else if (node.bal.getValue() < -1) { // right-heavy
			if (height(node.right.right) >= height(node.right.left)) {
				node = rotateRR(node);
			} else {
				node = rotateRL(node);
			}
		}
		return node;
	}

	//-------------------- updateBalance (null=-1, leaf=0)
	private void updateBalance(AVLNode<T> node) {
		int leftHeight = height(node.left);
		int rightHeight = height(node.right);
		int diff = leftHeight - rightHeight;
		if (diff == 1) {
			node.bal = Balance.PlusOne;
		} else if (diff == 0) {
			node.bal = Balance.Zero;
		} else {
			node.bal = Balance.MinusOne;
		}
	}

	//-------------------- height (null=-1, leaf=0)
	private int height(AVLNode<T> node) {
		if (node == null) {
			return -1;
		}
		return 1 + Math.max(height(node.left), height(node.right));
	}

	//-------------------- Rotations
	private AVLNode<T> rotateLL(AVLNode<T> node) {
		AVLNode<T> newRoot = node.left;
		node.left = newRoot.right;
		newRoot.right = node;
		updateBalance(node);
		updateBalance(newRoot);
		return newRoot;
	}

	private AVLNode<T> rotateRR(AVLNode<T> node) {
		AVLNode<T> newRoot = node.right;
		node.right = newRoot.left;
		newRoot.left = node;
		updateBalance(node);
		updateBalance(newRoot);
		return newRoot;
	}

	private AVLNode<T> rotateLR(AVLNode<T> node) {
		node.left = rotateRR(node.left);
		return rotateLL(node);
	}

	private AVLNode<T> rotateRL(AVLNode<T> node) {
		node.right = rotateLL(node.right);
		return rotateRR(node);
	}
}
